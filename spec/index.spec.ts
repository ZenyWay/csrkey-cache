/*
 * Copyright 2016 Stephane M. Catala
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *  http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * Limitations under the License.
 */
;
import getCache from '../src'
const Buffer = require('buffer').Buffer

let csrng: any
let cache: any
beforeEach(() => {
  csrng = jasmine.createSpy('csrng').and.returnValue(Uint8Array.of(42))
  cache = jasmine.createSpyObj('cache', [ 'set', 'del', 'get', 'has' ])
})

describe('default export: ' +
'getCache <V>(opts?: CsrKeyCacheFactoryOpts<V>): CsrKeyCache<V>',
() => {
  let csrKeyCacheInterface: any
  beforeEach(() => {
    csrKeyCacheInterface = jasmine.objectContaining({
      set: jasmine.any(Function),
      del: jasmine.any(Function),
      get: jasmine.any(Function),
      has: jasmine.any(Function)
    })
  })

  describe('when called without arguments', () => {
    let csrKeyCache: any
    beforeEach(() => {
      csrKeyCache = getCache()
    })

    it('returns a CsrKeyCache<V> instance', () => {
      expect(csrKeyCache).toEqual(csrKeyCacheInterface)
    })
  })
  describe('when called with { cache: Cache<string, V> }', () => {
    let csrKeyCache: any
    beforeEach(() => {
      csrKeyCache = getCache({ cache: cache })
      csrKeyCache.set('foo', 42)
      csrKeyCache.del('foo')
      csrKeyCache.get('foo')
      csrKeyCache.has('foo')
    })

    it('returns a CsrKeyCache<V> instance that wraps the given cache instance',
    () => {
      expect(cache).toEqual(csrKeyCacheInterface)
      expect(cache.set).toHaveBeenCalledWith(jasmine.any(String), 'foo', 42)
      expect(cache.del).toHaveBeenCalledWith('foo')
      expect(cache.get).toHaveBeenCalledWith('foo')
      expect(cache.has).toHaveBeenCalledWith('foo')
    })
  })
  describe('when called with { cache: CsrKeyCacheFactoryConfig<V> }', () => {
    let csrKeyCache: any
    let result: any
    beforeEach(() => {
      csrKeyCache = getCache({ cache: { max: 1 } })
      const foo = csrKeyCache.set('foo')
      const bar = csrKeyCache.set('bar')
      result = {
        foo: csrKeyCache.get(foo),
        bar: csrKeyCache.get(bar)
      }
    })

    it('returns a CsrKeyCache<V> instance that wraps an lru-cache instance ' +
    'with the given options', () => {
      expect(csrKeyCache).toEqual(csrKeyCacheInterface)
      expect(result).toEqual(jasmine.objectContaining({
        foo: undefined,
        bar: 'bar'
      }))
    })
  })
  describe('when called with { keylength: number }', () => {
    let csrKeyCache: any
    let key: any
    beforeEach(() => {
      csrKeyCache = getCache({ keylength: 42 })
      key = Buffer.from(csrKeyCache.set('foo'), 'base64')
    })

    it('returns a CsrKeyCache<V> instance that generates random base64 keys ' +
    'of the given number of bytes', () => {
      expect(csrKeyCache).toEqual(csrKeyCacheInterface)
      expect(key.length).toBe(42)
    })
  })

  describe('when called with { csrng: (length: number) => Uint8Array }', () => {
    let csrKeyCache: any
    let key: any
    beforeEach(() => {
      csrKeyCache = getCache({ csrng: csrng })
      key = csrKeyCache.set('foo')
    })

    it('returns a CsrKeyCache<V> instance that generates random base64 keys ' +
    'with the given random number generator', () => {
      expect(csrKeyCache).toEqual(csrKeyCacheInterface)
      expect(key).toBe(Buffer.from([42]).toString('base64'))
      expect(csrng).toHaveBeenCalledWith(jasmine.any(Number))
    })
  })
})

describe('CsrKeyCache<V>', () => {
  let csrKeyCache: any
  beforeEach(() => {
    csrKeyCache = getCache({ cache: cache, keylength: 6502, csrng: csrng })
  })

  describe('set (val: V, expire?: number): string|false', () => {
    let b64of42: string
    let key: any
    let success: any
    beforeEach(() => {
      b64of42 = Buffer.from([42]).toString('base64')
      let hasKey: boolean = true // simulate conflict after first call to csrng
      cache.set.and.callFake(() => hasKey = true)
      cache.has.and.callFake(() => !(hasKey = !hasKey)) // return hasKey then invert it
      key = csrKeyCache.set('bar') // should call csrng twice
      cache.has.and.returnValue(false)
      success = csrKeyCache.set('baz', 6510) // should call csrng once
    })

    it('generates and returns a unique base64 string key ' +
    'from random bytes generated by the CSRNG ', () => {
      expect(key).toBe(b64of42)
      expect(csrng).toHaveBeenCalledWith(6502)
      expect(csrng).toHaveBeenCalledTimes(3)
    })

    it('stores the given `val` in the cache under the generated key ', () => {
      expect(cache.set.calls.argsFor(0)).toEqual([b64of42, 'bar', undefined ])
      expect(cache.set.calls.argsFor(1)).toEqual([b64of42, 'baz', 6510])
    })

    it('returns false upon failure', () => {
      expect(success).toBe(false)
    })
  })

  describe('del (key: string): void', () => {
    beforeEach(() => {
      csrKeyCache.del('foo')
    })

    it('delegates to the `del` method of the underlying cache', () => {
      expect(cache.del).toHaveBeenCalledWith('foo')
    })
  })

  describe('get (key: string): V', () => {
    let val: any
    beforeEach(() => {
      cache.get.and.returnValue('bar')
      val = csrKeyCache.get('foo')
    })

    it('delegates to the `get` method of the underlying cache', () => {
      expect(cache.get).toHaveBeenCalledWith('foo')
      expect(val).toBe('bar')
    })
  })

  describe('has (key: string): boolean', () => {
    let hasKey: any
    beforeEach(() => {
      cache.has.and.returnValue(true)
      hasKey = csrKeyCache.has('foo')
    })

    it('delegates to the `has` method of the underlying cache', () => {
      expect(cache.has).toHaveBeenCalledWith('foo')
      expect(hasKey).toBe(true)
    })
  })
})